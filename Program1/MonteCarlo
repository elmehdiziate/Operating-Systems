#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[])
{

    char file_path[100];

    // check if the number of arguments passed is correct
    if (argc != 3)
    {
        printf("Usage: %s <file path> <number of processes>\n", argv[0]);
        return 1;
    }

    else
    {
        strcpy(file_path, argv[1]);
    }

    int number_processes = atoi(argv[2]);
    int total_points = 0;
    int count = 0;
    int total_points_in_circle = 0;
    int n = 0;
    int processed_points = 0;
    FILE *points = fopen(file_path, "r");
    float pts[1000][2];

    // check if file is opened
    if (points == NULL)
    {
        printf("Error: Unable to open file %s\n", file_path);
        return 1;
    }

    // check if the format of the file is valid
    if (fscanf(points, "%d", &total_points) != 1)
    {
        printf("Error: Invalid file format\n");
        fclose(points);
        return 1;
    }
    while (!feof(points))
    {
        if (fscanf(points, "%f %f", &pts[n][0], &pts[n][1]) != 2)
        {
            printf("Error: Invalid file format\n");
            fclose(points);
            return 1;
        }
        n++;
    }
    if (n != total_points)
    {
        printf("Error: Invalid file format\n");
        return 1;
    }
    // for(int i=0; i< total_points ; i++){
    //   printf("(%f , %f)\n",pts[i][0],pts[i][1]);
    // }

    // Create unnamed pipe to communicate with the children
    int pipefd[2];
    if (pipe(pipefd) == -1)
    {
        printf("Error: Unable to create pipe\n");
        fclose(points);
        return 1;
    }

    // Create child processes

    for (int i = 0; i < number_processes; i++)
    {

        pid_t pid = fork();
        if (pid < 0)
        {
            printf("Error: Unable to create child process\n");
            return 1;
        }
        else if (pid == 0)
        {
            // The child does not need the reading end of the pipe
            close(pipefd[0]);

            float x, y;
            int process_points_in_circle = 0;
            int points_per_process = total_points / number_processes;
            int reminder = total_points % number_processes;
            int start = processed_points;

            // Check if there is any left points after division : reminder = totalPoints % numProcesses != 0
            if (i < reminder)
            {
                // Add a point to the points_per_process
                points_per_process++;
            }

            // Start reading from pts[processed_points]
            for (int j = start; j < start + points_per_process; j++)
            {
                x = pts[j][0];
                y = pts[j][1];
                printf("(%f,%f)\n", x, y);
                printf("%f\n", x * x + y * y);
                // Check if the points are in the circle
                if (x * x + y * y <= 1)
                {
                    process_points_in_circle++;
                }
            }

            // Send the total_points_in_circle for each process to the parent
            write(pipefd[1], &process_points_in_circle, sizeof(process_points_in_circle));
            close(pipefd[1]);
            return 0;
        }
        processed_points += total_points / number_processes;
        if (i < total_points % number_processes)
        {
            processed_points++;
        }
    }
    // The parent does not need the writing end of the pipe
    close(pipefd[1]);
    for (int i = 0; i < number_processes; i++)
    {
        wait(0);
    }
    for (int i = 0; i < number_processes; i++)
    {
        int process_points_in_circle;
        read(pipefd[0], &process_points_in_circle, sizeof(process_points_in_circle));
        total_points_in_circle += process_points_in_circle;
    }

    close(pipefd[0]);

    // Calculate and print approximation of pi
    float pi = 4.0 * total_points_in_circle / total_points;
    printf("Approximation of pi: %f\n", pi);
    fclose(points);
    return 0;
}